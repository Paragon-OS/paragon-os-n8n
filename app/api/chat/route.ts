import { google } from "@ai-sdk/google";
import { streamText, UIMessage, convertToModelMessages, tool } from "ai";
import { z } from "zod";
import { callN8nWorkflow } from "@/lib/n8n-client";
import { getWorkflowWebhookUrl } from "@/lib/n8n-config";
import { getWebhookModeFromCookieHeader } from "@/lib/stores/webhook-mode";
import { getStreamingUpdateUrl } from "@/lib/n8n-client/config";
import { NextResponse } from "next/server";
import { saveChatMessagesToSupabase } from "@/lib/supabase/supabase-chat";
import { randomUUID } from "crypto";

/**
 * Zod schema for validating chat request body
 * Validates the messages array structure with flexible content formats
 */
const chatRequestSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant", "system", "tool"]),
      content: z.union([z.string(), z.array(z.unknown()), z.record(z.string(), z.unknown())]).optional(),
      parts: z.union([z.string(), z.array(z.unknown()), z.record(z.string(), z.unknown())]).optional(),
    }).passthrough() // Allow additional properties for flexibility
  ).min(1, "Messages array must contain at least one message"),
});

/**
 * Extract chatInput from messages array
 * Converts the conversation history into a format suitable for N8N workflows
 */
function extractChatInput(messages: UIMessage[]): string {
  if (!messages || messages.length === 0) {
    return "";
  }
  
  // Find the last user message
  const userMessages = messages.filter(m => m.role === "user");
  const lastUserMessage = userMessages[userMessages.length - 1];

  if (!lastUserMessage) {
    return "";
  }

  // UIMessage uses 'parts' array - extract text from text parts
  const textParts = lastUserMessage.parts
    .filter((part: any) => part.type === "text")
    .map((part: any) => part.text)
    .filter(Boolean);
  
  const content = textParts.join("");

  if (content && content.trim() !== "") {
    return content;
  }

  console.error("[extractChatInput] Failed to extract text from last user message");
  return "";
}

export async function POST(req: Request) {
  // Parse and validate request body
  let body: unknown;
  try {
    body = await req.json();
  } catch (error) {
    console.error("[chat/route] Failed to parse request body as JSON:", error);
    return NextResponse.json(
      {
        error: "Invalid JSON in request body",
        message: error instanceof Error ? error.message : "Failed to parse request body",
      },
      { status: 400 }
    );
  }

  // Validate request structure with Zod
  const validationResult = chatRequestSchema.safeParse(body);
  if (!validationResult.success) {
    console.error("[chat/route] Request validation failed:", validationResult.error.format());
    return NextResponse.json(
      {
        error: "Invalid request format",
        details: validationResult.error.format(),
        message: "The request body must contain a 'messages' array with at least one message object containing a 'role' field.",
      },
      { status: 400 }
    );
  }

  const { messages: validatedMessages } = validationResult.data;
  // Cast to UIMessage[] for AI SDK compatibility (Zod validation ensures structure is correct)
  // Note: UIMessage requires 'id' which may be generated by the client, so we cast through unknown
  const rawMessages = validatedMessages as unknown as UIMessage[];
  
  // Filter messages to ensure they end with a user message (required by Gemini API)
  // Remove any trailing assistant/system/tool messages
  let lastUserIndex = -1;
  for (let i = rawMessages.length - 1; i >= 0; i--) {
    if (rawMessages[i]?.role === "user") {
      lastUserIndex = i;
      break;
    }
  }
  
  // If no user message found, return error
  if (lastUserIndex === -1) {
    console.error("[chat/route] No user messages found in request");
    return NextResponse.json(
      {
        error: "Invalid request format",
        message: "Messages array must contain at least one user message",
      },
      { status: 400 }
    );
  }
  
  // Include all messages up to and including the last user message
  const messages = rawMessages.slice(0, lastUserIndex + 1);
  
  // Log if we removed any trailing messages
  if (rawMessages.length > messages.length) {
    const removedCount = rawMessages.length - messages.length;
    console.log(`[chat/route] Removed ${removedCount} trailing non-user message(s)`);
  }
  
  // Ensure we have at least one message
  if (messages.length === 0) {
    console.error("[chat/route] No user messages found after filtering");
    return NextResponse.json(
      {
        error: "Invalid request format",
        message: "Messages array must contain at least one user message",
      },
      { status: 400 }
    );
  }
  
  // Generate or extract session ID for chat persistence
  // In a real app, this would come from user session/authentication
  const headerSessionId = req.headers.get("x-session-id");
  const sessionId = headerSessionId || randomUUID();
  
  console.log("[chat/route] POST request received");
  console.log("[chat/route] x-session-id header:", headerSessionId);
  console.log("[chat/route] Final sessionId:", sessionId);
  console.log("[chat/route] Messages count:", messages.length);
  
  // Get webhook mode from cookies
  const cookieHeader = req.headers.get("cookie");
  const webhookMode = getWebhookModeFromCookieHeader(cookieHeader);

  const paragonOS = tool({
    description: "ParagonOS is an intelligent messaging platform management assistant with sophisticated Discord and Telegram agent tools. Use this tool when the user wants to interact with Discord or Telegram (check messages, send DMs/messages, search conversations, manage contacts, etc.). The agents automatically handle context enrichment, AI planning with playbooks, sequential MCP tool execution, and result validation with retries. Pass the user's request in natural language - the agents will handle all planning and execution automatically.",
    inputSchema: z.object({
      prompt: z.string().describe("Pass the user's request in natural language directly - the agents handle planning and execution automatically. Include clear intent about what the user wants (check messages, send DM/message, search topics, etc.), relevant context (channel/chat names, contact names, server/group names, time ranges, topics), and specify the platform (Discord, Telegram, or both). The sub-workflows will resolve names to IDs, plan multi-step operations, and handle retries. Examples: 'Check for unreplied messages in the wandrlust admin & dev channel', 'DM sebastian asking about the deployment status', 'Check for pending messages in both Discord and Telegram', 'What were the key points discussed about the token launch in metarune-labs?'"),
    }),
    execute: async ({ prompt }: { prompt: string }) => {
      // The prompt parameter is required by the schema
      let chatInput = prompt;
      
      // Validate the provided prompt
      if (!chatInput || chatInput.trim() === "") {
        chatInput = extractChatInput(messages);
      }
      
      // Final validation
      if (!chatInput || chatInput.trim() === "") {
        return {
          success: false,
          error: "Cannot send empty request. The prompt parameter must contain the user's actual request or question.",
        };
      }
      
      // Extract messageId from the last user message (the one that triggered this tool call)
      const userMessages = messages.filter(m => m.role === "user");
      const lastUserMessage = userMessages[userMessages.length - 1];
      const messageId = lastUserMessage?.id;
      
      // Get the stream URL for updates using unified URL construction
      const streamUrl = getStreamingUpdateUrl(req);
      
      // Prepare payload in the format N8N webhook expects
      const payload = {
        chatInput: chatInput,
        metadata: {
          sessionId: sessionId,
          messageId: messageId, // Always include messageId (may be undefined)
          streamUrl: streamUrl,
        },
      };
      
      const webhookUrl = getWorkflowWebhookUrl("paragonOS", webhookMode);
      if (!webhookUrl) {
        return {
          success: false,
          error: "ParagonOS workflow is not configured. Please set the webhook URL in n8n-config.ts",
        };
      }

      const result = await callN8nWorkflow({
        webhookUrl,
        method: "POST",
        payload,
      });

      if (!result.success) {
        return {
          success: false,
          error: result.error || "Failed to execute ParagonOS workflow",
        };
      }

      return {
        success: true,
        message: "Request sent to ParagonOS successfully",
        data: result.data,
      };
    },
  });

  try {
    const result = streamText({
      model: google("models/gemini-2.5-pro"),
      messages: convertToModelMessages(messages),
      system: `You are ParagonOS, an intelligent messaging platform management assistant supporting both Discord and Telegram.

# Your Capabilities:

You have access to two sophisticated agent tools:

**Discord Agent:**

- Automatically enriches requests with cached context (contacts, guilds, channels, your profile)

- Uses an AI planner with a playbook of common Discord workflows

- Generates and executes sequential MCP tool operations

- Validates results and retries with refined approaches if needed

**Telegram Agent:**

- Automatically enriches requests with cached context (contacts, chats, groups, your profile)

- Uses an AI planner with a playbook of common Telegram workflows

- Generates and executes sequential MCP tool operations

- Validates results and retries with refined approaches if needed

# How to Use the Agents:

1. **Pass natural language requests directly** - The agents handle planning and execution automatically

2. **Provide clear intent** - Be specific about what the user wants (check messages, send DM/message, search topics, etc.)

3. **Include relevant context** - Mention channel/chat names, contact names, server/group names, time ranges, or specific topics

4. **Specify the platform** - Clearly indicate whether the request is for Discord or Telegram (or both)

5. **Trust the sub-workflows** - They will resolve names to IDs, plan multi-step operations, and handle retries

# Good Examples:

**Discord Examples:**

- "Check for unreplied messages in the wandrlust admin & dev channel"

- "DM sebastian asking about the deployment status"

- "What were the key points discussed about the token launch in metarune-labs?"

- "Show me all pending DMs that need my attention"

- "Find and list all messages from the past week in the dev-team channel"

**Telegram Examples:**

- "Check for unreplied messages from sebastian in Telegram"

- "Message john about the meeting in Telegram"

- "What did people say about the launch in the dev group on Telegram?"

- "Show me all pending chats that need my attention in Telegram"

- "Find and list all messages from the past week in the team group on Telegram"

**Cross-Platform Examples:**

- "Check for pending messages in both Discord and Telegram"

- "Send a message to sebastian on both platforms about the meeting"

- "What's new in my Discord DMs and Telegram chats?"

# Your Role:

- Understand user intent and reformulate as clear, actionable requests

- Determine which platform(s) the user wants to interact with (Discord, Telegram, or both)

- Interpret the agent results and present them conversationally

- Handle multi-turn conversations with context from memory

- Ask clarifying questions if the user's request is ambiguous or doesn't specify a platform

When a user's request involves messaging operations on Discord or Telegram, use the paragonOS tool to pass their request in natural language. The underlying agents will handle all the planning, context enrichment, and execution automatically.`,
      tools: {
        paragonOS,
      },
      onFinish: async ({ text, toolCalls }) => {
        // Save ALL messages (user + assistant) once after streaming finishes
        // This ensures we save complete, validated data in a single transaction
        
        // Create the assistant message with the complete response
        const assistantMessage: UIMessage = {
          id: randomUUID(),
          role: "assistant",
          parts: [{ type: "text", text }],
        };

        // Add tool calls if present
        if (toolCalls && toolCalls.length > 0) {
          (assistantMessage as any).toolCalls = toolCalls;
        }

        // Save both user messages and assistant response together
        const allMessages = [...messages, assistantMessage];
        
        await saveChatMessagesToSupabase({
          sessionId,
          messages: allMessages,
          sessionTitle: extractChatInput(messages).substring(0, 100),
        }).catch((error) => {
          console.error("[chat/route] Error saving messages:", error);
        });
      },
    });

    // Return the streaming response directly
    return result.toTextStreamResponse();
  } catch (error) {
    console.error("[chat/route] Error processing chat request:", error);
    return NextResponse.json(
      {
        error: "Failed to process chat request",
        message: error instanceof Error ? error.message : "An unexpected error occurred",
      },
      { status: 500 }
    );
  }
}
